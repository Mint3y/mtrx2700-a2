/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"
#include "timer.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif






// enable the clocks for desired peripherals (GPIOA, C and E)
void enable_clocks() {

	RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIOEEN;    // Initialise GPIO ports



	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;    // Initialise Timer 2 base adress


}

// initialise the discovery board I/O (just outputs: inputs are selected by default)
void initialise_board() {

	// get a pointer to the second half word of the MODER register (for outputs pe8-15)
	uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1;   //GPIOE has 32 bits but uint16 breaks it into 2 of 16 sectiosn
	*led_output_registers = 0x5555;  // The current pattern of the leds


}


void trigger_prescaler() {

	TIM2->ARR = 0x01;
	TIM2->CNT = 0x00;
	asm("NOP");
	asm("NOP");
	asm("NOP");
	TIM2->ARR = 0xffffffff;

}

// Function being called back to

void change_pattern(uint8_t *led_pattern){

	*led_pattern = 0xAA;


}

void one_shot_pattern(uint8_t *led_pattern){

	*led_pattern = 0xFF;
    printf("One-shot callback executed\n");

}






// LED should blink every 1 second

int timer_main(void)
{



	//Initialise for 800 000 ticks for each state
	int shot_mode;

	uint32_t on_time = 0xC3500;  	// clock ticks for ON
	uint32_t off_time = 0x186A00; 	// clock ticks for OFF

	init_led_change(on_time, off_time, change_pattern); // Initialise Led change


	enable_clocks(); 				//  Enable the GPIO's
	initialise_board();				//  Define outputs




	TIM2->CR1 |= TIM_CR1_CEN;		// Enable the counter


	TIM2->PSC = 0x09;				// Define pre-scaler value
	trigger_prescaler();            // Enable system to initialise pre-scaler



	uint8_t led_mask_pattern = 0b01010101;
	uint8_t *led_output_register = ((uint8_t*)&(GPIOE->ODR)) + 1;  // Write pattern to upper byte of 16 bits

	/* Loop forever */
	for(;;) {

		one_shot_mode(&shot_mode);  	// Get status of one-shot

		TIM2->CNT = 0;              // Initialise timer count to 0

		changing_pattern(&(TIM2->CNT), led_output_register, led_mask_pattern); //  Triggers call_back function

		// Change period

		PeriodValues duration = get_current_period();

		if(duration.on_time == on_time && duration.off_time == off_time){      // obtain current on_time and off_time
			set_period(on_time*4, off_time *4);
		}
		else{
			set_period(on_time, off_time);
		}

		// trigger one_shot event

		if (shot_mode == 1){
			*led_output_register = 0x00;
			one_shot(10000, one_shot_pattern, led_output_register);
			set_period(on_time, off_time);

		}



	}

}

